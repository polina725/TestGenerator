using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using NLog;
using NLog.Config;
using NLog.Targets;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Moq;

namespace Tests
{
    [TestClass]
    public class Testing
    {

        private List<Generator.GeneratedFileInfo> generatedTests;
        private SyntaxNode root;
        private Logger log;

        [TestInitialize]
        public void Init()
        {
            var config = new LoggingConfiguration();
            var consoleTarget = new FileTarget
            {
                FileName = "log.txt",
                Layout = "${date:format=HH\\:MM\\:ss} ${logger} ${message}",
            };
            config.AddRule(LogLevel.Debug, LogLevel.Fatal, consoleTarget, "*");
            LogManager.Configuration = config;
            log = LogManager.GetCurrentClassLogger();
            Generator.Generator gen = new Generator.Generator("..\\..\\..\\Output");
            generatedTests = gen.AnalyseFile(File.ReadAllText("..\\..\\..\\Input\\Exemple.cs"));
            root = CSharpSyntaxTree.ParseText(generatedTests[1].SourceCode).GetRoot();
        }

        [TestMethod]
        public void AmountOfGeneratedTests()
        {
            log.Info("Start");
            Assert.AreEqual(3,generatedTests.Count);
            log.Info("Test end");
        }

        [TestMethod]
        public void NamespaceNameCheck()
        {
            log.Info("Start");
            IEnumerable<string> namespaces = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>().Select(node => node.Name.ToString());
         //   log.Info($"\tGot namespaces: {namespaces.ToString()}");
            Assert.AreEqual("tests", namespaces.First());
            log.Info("End");
        }

        [TestMethod]
        public void UsingsNamesCheck()
        {
            log.Info("Start");
            string[] expectedUsingsNames = { "System", "System.Linq", "System.Collections.Generic", "NuGet.Frameworks" };
            string[] usings = root.DescendantNodes().OfType<UsingDirectiveSyntax>().Select(node => node.Name.ToString()).ToArray();
            log.Info($"\tGot namespaces: {usings}");
            CheckNames(usings, expectedUsingsNames);
            log.Info("End");
        }

        [TestMethod]
        public void ClassNameCheck()
        {
            log.Info("Start");
            string[] classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>().Select(node => node.Identifier.ValueText).ToArray();
            log.Info($"\tGot classes: {classes}");
            Assert.AreEqual(1, classes.Length);
            Assert.AreEqual("AnotherClassTest", classes[0]);
            log.Info("End");
        }

        [TestMethod]
        public void MethodsNamesCheck()
        {
            log.Info("Start");
            string[] methods = root.DescendantNodes().OfType<MethodDeclarationSyntax>().Select(node => node.Identifier.ValueText).ToArray();
            log.Info($"\tGot methods: {methods}");
            Assert.AreEqual(2,methods.Length);
            string[] expectedMethodsNames = { "FirstMethodATest", "SecondMethodATest" };
            CheckNames(methods, expectedMethodsNames);
            log.Info("End");
        }

        [TestMethod]
        public void MethodBodyCheck()
        {
            log.Info("Start");
            SyntaxList<StatementSyntax> bodies = root.DescendantNodes().OfType<MethodDeclarationSyntax>().Select(node => node.Body.Statements).First();
            log.Info($"\tGot method bodies: {bodies}");
            Assert.AreEqual("Assert.Fail(\"autogenerated\");", bodies.First().ToString());
            log.Info("End");
        }

        private void CheckNames(string[] actualNames, string[] expectedNames)
        {
            log.Info($"\tChecking names:");
            foreach (string actualName in actualNames)
            { 
                if (!NameCorrect(actualName, expectedNames))
                    Assert.Fail($"Wrong name: {actualName}\n");
            }
        }

        private bool NameCorrect(string name,string[] expectedNames)
        {
            foreach (string _name in expectedNames)
            {
                log.Info($"\t\t{_name} and {name}");
                if (name == _name)
                    return true;
            }
            return false;
        }
    }
}
